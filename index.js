const { execSync } = require("child_process")
const NodeID3 = require("node-id3")
const path = require("path")
const fs = require("fs")
const glob = require("glob")

function safeFilename(name) {
  // reserved character
  let safe = name.replace(/[\/\\:\*\?"<>\|]/g, "_")

  safe = safe.replace(/[. ]+$/, "")

  // windows reserved names
  const reserved = /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i
  if (reserved.test(safe)) {
    safe = `_${safe}`
  }

  return safe
}


function downloadTrack(videoUrl, tempDir = "./temp") {
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true })
  }

  const outputTemplate = path.join(tempDir, "song")

  const cmd = `
    yt-dlp \
    -f bestaudio \
    --no-post-overwrites \
    --no-post-overwrite \
    --write-thumbnail \
    --write-info-json \
    --output "${outputTemplate}.%(ext)s" \
    "${videoUrl}"
    `

  try {
    console.log("Running yt-dlp...")
    execSync(cmd, { stdio: "inherit" })
    console.log("Download finished.")

    const matches = glob.sync(path.join(tempDir, "song.*"))
    const inputFile = matches.find(f => !f.endsWith(".jpg") && !f.endsWith(".webp") && !f.endsWith(".json"))
    if (!inputFile) throw new Error("No audio file found from yt-dlp")

    const outputFile = path.join(tempDir, "song.mp3")
    const ffmpegCmd = `
        ffmpeg -y -i "${inputFile}" -codec:a libmp3lame -b:a 256k -q:a 0 "${outputFile}"
        `
    console.log("Running ffmpeg...")
    execSync(ffmpegCmd, { stdio: "inherit" })
    console.log("ffmpeg finished, MP3 ready.")
  } catch (err) {
    console.error("Download/conversion failed:", err)
    return
  }

  const thumbFile = fs.readdirSync(tempDir).find(f =>
    f.match(/\.(jpe?g|png|webp)$/i)
  )
  if (thumbFile) {
    const thumbPath = path.join(tempDir, thumbFile)
    const croppedPath = path.join(tempDir, "cover.png")

    // crop to 720x720 square
    const cropCmd = `magick "${thumbPath}" -thumbnail 720x720^ -gravity center -extent 720x720 -quality 90 "${croppedPath}"`
    execSync(cropCmd, { stdio: "inherit" })
  }

  const infoPath = path.join(tempDir, "song.info.json")
  let description = null

  if (fs.existsSync(infoPath)) {
    try {
      const infoData = JSON.parse(fs.readFileSync(infoPath, "utf8"))
      if (infoData.description) {
        description = infoData.description
      }
    } catch (err) {
      console.error("Failed to read info.json:", err)
      return
    }
  }

  console.log(description)

  metadata = parseMetadataFromDescription(description)

  console.log(metadata)

  if (!metadata.isAutoGenerated) {
    const manualMetaPath = path.join(tempDir, "songmetadata.json")
    const fd = fs.openSync('/dev/stdin', 'rs')

    // seed defaults from yt-dlp's info.json if available
    let seed = {
      title: "EDIT THIS",
      artists: ["EDIT THIS"],
      album: "EDIT THIS",
      date: "EDIT THIS",   // renamed from year
      description: "",
      extraRoles: {}
    }

    try {
      if (fs.existsSync(infoPath)) {
        const info = JSON.parse(fs.readFileSync(infoPath, "utf8"))
        if (info.title) seed.title = info.title
        if (info.uploader) seed.artists = [info.uploader]
        if (info.upload_date && /^\d{8}$/.test(info.upload_date)) {
          // convert YYYYMMDD → YYYY-MM-DD
          seed.date = `${info.upload_date.slice(0, 4)}-${info.upload_date.slice(4, 6)}-${info.upload_date.slice(6, 8)}`
        }
        // if (info.description) seed.description = info.description
      }
    } catch (err) {
      console.warn("Could not parse yt-dlp info.json for defaults:", err)
    }

    // write template only if it doesn't already exist
    if (!fs.existsSync(manualMetaPath)) {
      fs.writeFileSync(manualMetaPath, JSON.stringify(seed, null, 2), "utf8")
    }

    console.log("\nYoutube video is not an art track.")
    console.log("Please populate the fields in temp/songmetadata.json before proceeding.")
    console.log("(You can also edit the album cover while this program waits)")
    while (true) {
      console.log("Hit [Enter] to continue\n")

      // block until Enter
      // there has to be a better way
      const buf = Buffer.alloc(1)
      while (true) {
        fs.readSync(fd, buf, 0, 1, null)
        if (buf[0] === 10) break; // newline
      }

      try {
        const manualData = JSON.parse(fs.readFileSync(manualMetaPath, "utf8"))

        const bad =
          !manualData.title || manualData.title === "EDIT THIS" ||
          !Array.isArray(manualData.artists) || manualData.artists.length === 0 || manualData.artists[0] === "EDIT THIS" ||
          !manualData.album || manualData.album === "EDIT THIS" ||
          !manualData.date || manualData.date === "EDIT THIS"

        if (!bad) {
          metadata = manualData
          break; // success
        }

        console.error("Metadata validation failed. Please edit temp/songmetadata.json and try again.")
      } catch (err) {
        console.error("Failed to read manual metadata file:", err)
      }
    }

  }

  const mp3Path = path.join(tempDir, "song.mp3")
  const coverPath = path.join(tempDir, "cover.png")

  const tags = {
    title: metadata.title || "",
    artist: (metadata.artists || []).join(", "),
    album: metadata.album || metadata.title, // singles fallback
    // date: metadata.date || "", seems to be throwing easytag off
    composer: metadata.composer || "",
    lyricist: metadata.lyricist || "",
    year: metadata.date ? metadata.date.slice(0, 4) : "", // just the year
    image: fs.existsSync(coverPath) ? {
      mime: "image/png",
      type: { id: 3, name: "front cover" },
      description: "Cover",
      imageBuffer: fs.readFileSync(coverPath)
    } : undefined
  }

  // flatten extra roles into TXXX frames
  if (metadata.extraRoles) {
    for (const [role, name] of Object.entries(metadata.extraRoles)) {
      tags[`TXXX:${role}`] = name
    }
  }

  try {
    NodeID3.update(tags, mp3Path)
    console.log("Metadata written to MP3.")
  } catch (err) {
    console.error("Failed to write tags:", err)
  }

  const safeTitle = safeFilename(metadata.title)
  const firstArtist = metadata.artists && metadata.artists.length > 0
    ? metadata.artists[0]
    : "Unknown"

  const safeArtist = safeFilename(firstArtist)

  // "wildcard" goes here.
  const finalName = `${safeArtist} - ${safeTitle}.mp3`

  // TODO: Join path with optional destination folder
  const finalPath = finalName

  fs.copyFileSync(mp3Path, finalPath)
  console.log(`Saved to ${finalPath}`)

  fs.rmSync(tempDir, { recursive: true, force: true })
  console.log("Temp folder deleted.")
}

function parseMetadataFromDescription(desc) {
  const lines = desc.split("\n").map(l => l.trim()).filter(line => line !== "")
  console.log(lines)

  const result = {
    title: null,          // TIT2
    artists: [],          // TPE1
    album: null,          // TALB
    composer: [],         // TCOM
    lyricist: [],         // TEXT
    date: null,           // TDRC
    copyright: null,      // TCOP
    publisher: null,      // TPUB
    extraRoles: {},       // TXXX for additional credits
    isAutoGenerated: false
  }

  result.isAutoGenerated = /Auto-generated by YouTube\./i.test(desc)

  // video is not an art track, return almost empty result
  if (!result.isAutoGenerated) {
    return result
  }

  const providerLine = lines.find(l => /^Provided to YouTube by/i.test(l))
  if (providerLine) {
    result.publisher = providerLine.replace(/^Provided to YouTube by/i, "").trim()
  }

  const copyrightLine = lines.find(l => /^℗/.test(l))
  if (copyrightLine) {
    result.copyright = copyrightLine
  }

  const releaseLine = lines.find(l => /^Released on:/i.test(l))
  if (releaseLine) {
    result.date = releaseLine.replace(/^Released on:/i, "").trim()
  }

  // extraRoles bit is fucked.
  lines.forEach(l => {
    const match = /^([^:]+):\s*(.+)$/.exec(l)
    if (match) {
      const role = match[1].trim()
      const name = match[2].trim()
      if (/^composer$/i.test(role)) result.composer.push(name)
      else if (/^lyricist$/i.test(role)) result.lyricist.push(name)
      else if (!/^released on$/i.test(role)) result.extraRoles[role] = name
    }
  })

  const titleArtistIndex = lines.findIndex((l, idx) => idx > 0 && l.includes("·"))
  if (titleArtistIndex !== -1) {
    const titleArtistLine = lines[titleArtistIndex]
    const parts = titleArtistLine.split("·").map(p => p.trim())
    result.title = parts[0]

    const rawArtists = parts.slice(1)
    rawArtists.forEach(part => {
      part
        .split(/feat\.|featuring|&|,/i)
        .map(a => a.trim())
        .filter(Boolean)
        .forEach(a => result.artists.push(a))
    })

    // album = next line if it’s not copyright or release info
    if (lines[titleArtistIndex + 1] && !/^℗|^Released on:/i.test(lines[titleArtistIndex + 1])) {
      result.album = lines[titleArtistIndex + 1]
    }
  }

  // fallback title if no "·" line
  if (!result.title && lines.length > 1) {
    result.title = lines[1]
  }

  // deduplicate arrays
  result.artists = result.artists.filter((a, i, arr) => arr.indexOf(a) === i)
  result.composer = result.composer.filter((a, i, arr) => arr.indexOf(a) === i)
  result.lyricist = result.lyricist.filter((a, i, arr) => arr.indexOf(a) === i)

  return result
}

if (process.argv.length < 3) {
  console.error("Usage: node script.js <youtube_url>")
  process.exit(1)
}

const videoUrl = process.argv[2]

if (videoUrl.includes("list=")) {
  console.error("Playlist detected. Playlist handling is not implemented yet.")
  process.exit(1)
}

downloadTrack(videoUrl)
